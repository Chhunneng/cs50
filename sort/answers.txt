sort1 uses: Bubble Sort

How do you know?:
- The runtime increases significantly as the input size grows, especially for reversed and sorted inputs. Bubble sort has a time complexity of O(n^2), and the observed runtimes match this behavior.
- Bubble sort repeatedly compares and swaps adjacent elements, and this behavior is reflected in the runtime results.

sort2 uses: Merge Sort

How do you know?:
- The runtime is relatively consistent across different input sizes, and it does not exhibit the same sharp increase as selection sort and bubble sort for larger inputs. Merge sort has a time complexity of O(n log n), which is more efficient than O(n^2) algorithms.
- Merge sort divides the array into smaller parts and recursively sorts them, which aligns with the observed runtime behavior.

sort3 uses: Selection Sort

How do you know?:
- The runtime increases significantly as the input size grows, especially for reversed and sorted inputs. Selection sort has a time complexity of O(n^2), and the observed runtimes match this behavior.
- Selection sort iterates through the unsorted portions of a list, selecting the smallest element each time and moving it to its correct location, which aligns with the observed runtime behavior.
